\hypertarget{dmx_8h}{}\section{values\+\_\+handler/src/dmx.h File Reference}
\label{dmx_8h}\index{values\+\_\+handler/src/dmx.\+h@{values\+\_\+handler/src/dmx.\+h}}


Header file for \hyperlink{dmx_8c}{dmx.\+c}.  


{\ttfamily \#include \char`\"{}constants.\+h\char`\"{}}\\*
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{dmx_8h_ad538292407ecde431f95b743e8744cc3}{dmx\+Open} (uint8\+\_\+t $\ast$$\ast$shm\+Values)
\begin{DoxyCompactList}\small\item\em Initialise the connection with the deamon. \end{DoxyCompactList}\item 
void \hyperlink{dmx_8h_a457b1885f3d820b1091efe434f0dc426}{dmx\+Close} ()
\begin{DoxyCompactList}\small\item\em End connection. \end{DoxyCompactList}\item 
void \hyperlink{dmx_8h_ac2b6017556ec382119eb22c609757362}{dmx\+Set\+Values} (unsigned int from\+Ch, int count, uint8\+\_\+t values\mbox{[}$\,$\mbox{]})
\begin{DoxyCompactList}\small\item\em Updates values in S\+H\+M. \end{DoxyCompactList}\item 
bool \hyperlink{dmx_8h_a40e5881f9c001c5cc38554084751adbc}{is\+Running} ()
\begin{DoxyCompactList}\small\item\em Checks if the deamon is running. \end{DoxyCompactList}\item 
void \hyperlink{dmx_8h_ac09ffdb579c9017063a60159df29264e}{print\+S\+H\+M\+State} ()
\begin{DoxyCompactList}\small\item\em S\+H\+M dump helper. \end{DoxyCompactList}\item 
void \hyperlink{dmx_8h_ad824dc21b5a00b1eb68d686ca8ee85a0}{switch\+\_\+to\+\_\+idle\+\_\+state} ()
\begin{DoxyCompactList}\small\item\em Idle state switcher helper. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Header file for \hyperlink{dmx_8c}{dmx.\+c}. 

\begin{DoxyAuthor}{Author}
Louis Blin N\+B\+: based on Velleman K8062 D\+M\+X controller library for V\+M116/\+K8062 used in the D\+M\+X\+Wheel project -\/ www.\+dmxwheel.\+com 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
June 2015 
\end{DoxyDate}


\subsection{Function Documentation}
\hypertarget{dmx_8h_a457b1885f3d820b1091efe434f0dc426}{}\index{dmx.\+h@{dmx.\+h}!dmx\+Close@{dmx\+Close}}
\index{dmx\+Close@{dmx\+Close}!dmx.\+h@{dmx.\+h}}
\subsubsection[{dmx\+Close()}]{\setlength{\rightskip}{0pt plus 5cm}void dmx\+Close (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{dmx_8h_a457b1885f3d820b1091efe434f0dc426}


End connection. 

Detaches from shared memory segment, and frees any variable still allocated. \hypertarget{dmx_8h_ad538292407ecde431f95b743e8744cc3}{}\index{dmx.\+h@{dmx.\+h}!dmx\+Open@{dmx\+Open}}
\index{dmx\+Open@{dmx\+Open}!dmx.\+h@{dmx.\+h}}
\subsubsection[{dmx\+Open(uint8\+\_\+t $\ast$$\ast$shm\+Values)}]{\setlength{\rightskip}{0pt plus 5cm}int dmx\+Open (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$$\ast$}]{shm\+Values}
\end{DoxyParamCaption}
)}\label{dmx_8h_ad538292407ecde431f95b743e8744cc3}


Initialise the connection with the deamon. 

Opens the dmx shared memory segment with the deamon dmxd.\+c.


\begin{DoxyParams}{Parameters}
{\em shm\+Values} & a pointer to be assigned to the first values in the S\+H\+M. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a negative value if something went wrong. 
\end{DoxyReturn}
\hypertarget{dmx_8h_ac2b6017556ec382119eb22c609757362}{}\index{dmx.\+h@{dmx.\+h}!dmx\+Set\+Values@{dmx\+Set\+Values}}
\index{dmx\+Set\+Values@{dmx\+Set\+Values}!dmx.\+h@{dmx.\+h}}
\subsubsection[{dmx\+Set\+Values(unsigned int from\+Ch, int count, uint8\+\_\+t values[])}]{\setlength{\rightskip}{0pt plus 5cm}void dmx\+Set\+Values (
\begin{DoxyParamCaption}
\item[{unsigned int}]{from\+Ch, }
\item[{int}]{count, }
\item[{uint8\+\_\+t}]{values\mbox{[}$\,$\mbox{]}}
\end{DoxyParamCaption}
)}\label{dmx_8h_ac2b6017556ec382119eb22c609757362}


Updates values in S\+H\+M. 

Sets a continuous block of {\ttfamily count} channels starting at {\ttfamily from\+Ch} with the values {\ttfamily values\mbox{[}\mbox{]}}.


\begin{DoxyParams}{Parameters}
{\em from\+Ch} & the index of the first value to update. \\
\hline
{\em count} & the number of channels to update. \\
\hline
{\em values} & the array of new values. \\
\hline
\end{DoxyParams}
\hypertarget{dmx_8h_a40e5881f9c001c5cc38554084751adbc}{}\index{dmx.\+h@{dmx.\+h}!is\+Running@{is\+Running}}
\index{is\+Running@{is\+Running}!dmx.\+h@{dmx.\+h}}
\subsubsection[{is\+Running()}]{\setlength{\rightskip}{0pt plus 5cm}bool is\+Running (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{dmx_8h_a40e5881f9c001c5cc38554084751adbc}


Checks if the deamon is running. 

\begin{DoxyReturn}{Returns}
Returns true if the control register of the S\+H\+M indicates that the deamon is running. False otherwise. 
\end{DoxyReturn}
\hypertarget{dmx_8h_ac09ffdb579c9017063a60159df29264e}{}\index{dmx.\+h@{dmx.\+h}!print\+S\+H\+M\+State@{print\+S\+H\+M\+State}}
\index{print\+S\+H\+M\+State@{print\+S\+H\+M\+State}!dmx.\+h@{dmx.\+h}}
\subsubsection[{print\+S\+H\+M\+State()}]{\setlength{\rightskip}{0pt plus 5cm}void print\+S\+H\+M\+State (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{dmx_8h_ac09ffdb579c9017063a60159df29264e}


S\+H\+M dump helper. 

Prints the shared memory using the util.\+c function \hyperlink{utils_8c_a8f9bc92ab5c582c7a075b74947b32736}{print\+S\+H\+M()}. \hypertarget{dmx_8h_ad824dc21b5a00b1eb68d686ca8ee85a0}{}\index{dmx.\+h@{dmx.\+h}!switch\+\_\+to\+\_\+idle\+\_\+state@{switch\+\_\+to\+\_\+idle\+\_\+state}}
\index{switch\+\_\+to\+\_\+idle\+\_\+state@{switch\+\_\+to\+\_\+idle\+\_\+state}!dmx.\+h@{dmx.\+h}}
\subsubsection[{switch\+\_\+to\+\_\+idle\+\_\+state()}]{\setlength{\rightskip}{0pt plus 5cm}void switch\+\_\+to\+\_\+idle\+\_\+state (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{dmx_8h_ad824dc21b5a00b1eb68d686ca8ee85a0}


Idle state switcher helper. 

Called if the program has to close after an unexpected error occured. 